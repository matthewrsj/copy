// Code generated by protoc-gen-go. DO NOT EDIT.
// source: terminal.proto

package asrs

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LoadOperationState int32

const (
	// Default state of slots assumed unavailable.
	LoadOperationState_NotReadyToLoad LoadOperationState = 0
	// PreparedForDelivery indicates the preferred location to load next. This is issued by Terminal to indicate that
	// slot is free and current preferred target for load. Location would be set by terminal. The state is requested
	// from Conductor to Terminal (desired) when Conductor has tray to deliver and wishes to determine where tray should
	// be delivered. Conductor may leave the location in the request empty and it is up to terminal to provide the target
	// location. Conductor may also specify a general area and Terminal may provide a destination more specific within
	// the area. Using CM Formation for example, where an aisle has been picked based on aisle occupancy, Conductor might
	// send a desired state of PreparedForDelivery with Location set to CM:CM2-63001-00-000, and Terminal might return
	// a current state of PreparedForDelivery with Location set to CM:CM2-63001-01-R08 (i.e. Conductor asks for destination
	// in aisle 1 and gets a destination from Terminal of aisle 1, tower 1, right side, level 8).
	// The request from Conductor to Terminal will carry the recipe for the tray.
	LoadOperationState_PreparedForDelivery LoadOperationState = 1
	// State where permission has been granted for conveyance to deliver load. This is issued by Terminal to conductor
	// to provide permission, and from Conductor to Terminal (desired) to request permission once conveyance has brought
	// payload to the Terminal and prior to loading. This request will also carry the desired recipe.
	LoadOperationState_PreparedToAccept LoadOperationState = 2
	// State conveyed by Conductor to Terminal (indicating conveyance has completed load) and Terminal will
	// execute. (This is symmetric with start of Unload operation where we start with Executed state).
	LoadOperationState_Loaded LoadOperationState = 3
)

var LoadOperationState_name = map[int32]string{
	0: "NotReadyToLoad",
	1: "PreparedForDelivery",
	2: "PreparedToAccept",
	3: "Loaded",
}

var LoadOperationState_value = map[string]int32{
	"NotReadyToLoad":      0,
	"PreparedForDelivery": 1,
	"PreparedToAccept":    2,
	"Loaded":              3,
}

func (x LoadOperationState) String() string {
	return proto.EnumName(LoadOperationState_name, int32(x))
}

func (LoadOperationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ff8b8260c8ef16ad, []int{0}
}

type UnloadOperationState int32

const (
	// Default state of slots assumed not willing to unload.
	UnloadOperationState_NotReadyToUnload UnloadOperationState = 0
	// Executed indicates the preferred location to unload next. This is issued by Terminal to Conductor to indicate that
	// slot job is ready and current preferred target for unload.
	UnloadOperationState_Executed UnloadOperationState = 1
	// State where permission has been granted for conveyance to pick up load. This is issued by Terminal to conductor
	// to provide permission, and from Conductor to Terminal (desired) to request permission once conveyance has prepared
	// conveyance for picking up at Terminal.
	UnloadOperationState_PreparedToUnload UnloadOperationState = 2
	// State indicating conveyance has picked up load and issued from Conductor To Terminal.
	UnloadOperationState_Unloaded UnloadOperationState = 3
)

var UnloadOperationState_name = map[int32]string{
	0: "NotReadyToUnload",
	1: "Executed",
	2: "PreparedToUnload",
	3: "Unloaded",
}

var UnloadOperationState_value = map[string]int32{
	"NotReadyToUnload": 0,
	"Executed":         1,
	"PreparedToUnload": 2,
	"Unloaded":         3,
}

func (x UnloadOperationState) String() string {
	return proto.EnumName(UnloadOperationState_name, int32(x))
}

func (UnloadOperationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ff8b8260c8ef16ad, []int{1}
}

// A State and Status combo for load operation state; status described whether we have successfully
// completed the transition into the state, or whether the internal state machine for the state is faulted.
type LoadOperationStateAndStatus struct {
	State LoadOperationState `protobuf:"varint,1,opt,name=state,proto3,enum=LoadOperationState" json:"state,omitempty"`
	// Is this state conveying a desired state or actual state
	StateType StateType `protobuf:"varint,2,opt,name=state_type,json=stateType,proto3,enum=result.StateType" json:"state_type,omitempty"`
	// Status indicates whether state transition completed successfully or faulted.
	Status               *Status  `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadOperationStateAndStatus) Reset()         { *m = LoadOperationStateAndStatus{} }
func (m *LoadOperationStateAndStatus) String() string { return proto.CompactTextString(m) }
func (*LoadOperationStateAndStatus) ProtoMessage()    {}
func (*LoadOperationStateAndStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff8b8260c8ef16ad, []int{0}
}

func (m *LoadOperationStateAndStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoadOperationStateAndStatus.Unmarshal(m, b)
}
func (m *LoadOperationStateAndStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoadOperationStateAndStatus.Marshal(b, m, deterministic)
}
func (m *LoadOperationStateAndStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadOperationStateAndStatus.Merge(m, src)
}
func (m *LoadOperationStateAndStatus) XXX_Size() int {
	return xxx_messageInfo_LoadOperationStateAndStatus.Size(m)
}
func (m *LoadOperationStateAndStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadOperationStateAndStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LoadOperationStateAndStatus proto.InternalMessageInfo

func (m *LoadOperationStateAndStatus) GetState() LoadOperationState {
	if m != nil {
		return m.State
	}
	return LoadOperationState_NotReadyToLoad
}

func (m *LoadOperationStateAndStatus) GetStateType() StateType {
	if m != nil {
		return m.StateType
	}
	return StateType_UnusedStateType
}

func (m *LoadOperationStateAndStatus) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type LoadOperation struct {
	Conversation *Conversation `protobuf:"bytes,1,opt,name=conversation,proto3" json:"conversation,omitempty"`
	// Payload identity
	Tray *Tray `protobuf:"bytes,2,opt,name=tray,proto3" json:"tray,omitempty"`
	// state indicates the desired or current state and status.
	State *LoadOperationStateAndStatus `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// ack indicates whether this message is acknowledging a current or desired state.
	Ack      bool      `protobuf:"varint,4,opt,name=ack,proto3" json:"ack,omitempty"`
	Location *Location `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
	// Recipe step to be executed at target.
	Recipe               *Recipe  `protobuf:"bytes,6,opt,name=recipe,proto3" json:"recipe,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadOperation) Reset()         { *m = LoadOperation{} }
func (m *LoadOperation) String() string { return proto.CompactTextString(m) }
func (*LoadOperation) ProtoMessage()    {}
func (*LoadOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff8b8260c8ef16ad, []int{1}
}

func (m *LoadOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoadOperation.Unmarshal(m, b)
}
func (m *LoadOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoadOperation.Marshal(b, m, deterministic)
}
func (m *LoadOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadOperation.Merge(m, src)
}
func (m *LoadOperation) XXX_Size() int {
	return xxx_messageInfo_LoadOperation.Size(m)
}
func (m *LoadOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadOperation.DiscardUnknown(m)
}

var xxx_messageInfo_LoadOperation proto.InternalMessageInfo

func (m *LoadOperation) GetConversation() *Conversation {
	if m != nil {
		return m.Conversation
	}
	return nil
}

func (m *LoadOperation) GetTray() *Tray {
	if m != nil {
		return m.Tray
	}
	return nil
}

func (m *LoadOperation) GetState() *LoadOperationStateAndStatus {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *LoadOperation) GetAck() bool {
	if m != nil {
		return m.Ack
	}
	return false
}

func (m *LoadOperation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *LoadOperation) GetRecipe() *Recipe {
	if m != nil {
		return m.Recipe
	}
	return nil
}

// A State and Status combo for unload operation state; status described whether we have successfully
// completed the transition into the state, or whether the internal state machine for the state is faulted.
type UnloadOperationStateAndStatus struct {
	State UnloadOperationState `protobuf:"varint,1,opt,name=state,proto3,enum=UnloadOperationState" json:"state,omitempty"`
	// Is this state conveying a desired state or actual state
	StateType StateType `protobuf:"varint,2,opt,name=state_type,json=stateType,proto3,enum=result.StateType" json:"state_type,omitempty"`
	// Status indicates whether state transition completed successfully or faulted.
	Status               *Status  `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnloadOperationStateAndStatus) Reset()         { *m = UnloadOperationStateAndStatus{} }
func (m *UnloadOperationStateAndStatus) String() string { return proto.CompactTextString(m) }
func (*UnloadOperationStateAndStatus) ProtoMessage()    {}
func (*UnloadOperationStateAndStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff8b8260c8ef16ad, []int{2}
}

func (m *UnloadOperationStateAndStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnloadOperationStateAndStatus.Unmarshal(m, b)
}
func (m *UnloadOperationStateAndStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnloadOperationStateAndStatus.Marshal(b, m, deterministic)
}
func (m *UnloadOperationStateAndStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnloadOperationStateAndStatus.Merge(m, src)
}
func (m *UnloadOperationStateAndStatus) XXX_Size() int {
	return xxx_messageInfo_UnloadOperationStateAndStatus.Size(m)
}
func (m *UnloadOperationStateAndStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UnloadOperationStateAndStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UnloadOperationStateAndStatus proto.InternalMessageInfo

func (m *UnloadOperationStateAndStatus) GetState() UnloadOperationState {
	if m != nil {
		return m.State
	}
	return UnloadOperationState_NotReadyToUnload
}

func (m *UnloadOperationStateAndStatus) GetStateType() StateType {
	if m != nil {
		return m.StateType
	}
	return StateType_UnusedStateType
}

func (m *UnloadOperationStateAndStatus) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type UnloadOperation struct {
	Conversation *Conversation `protobuf:"bytes,1,opt,name=conversation,proto3" json:"conversation,omitempty"`
	Tray         *Tray         `protobuf:"bytes,2,opt,name=tray,proto3" json:"tray,omitempty"`
	// state indicates the desired or current state and status.
	State *UnloadOperationStateAndStatus `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// ack indicates whether this message is acknowledging a current or desired state.
	Ack                  bool            `protobuf:"varint,4,opt,name=ack,proto3" json:"ack,omitempty"`
	Location             *Location       `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
	Results              *ProcessResults `protobuf:"bytes,6,opt,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UnloadOperation) Reset()         { *m = UnloadOperation{} }
func (m *UnloadOperation) String() string { return proto.CompactTextString(m) }
func (*UnloadOperation) ProtoMessage()    {}
func (*UnloadOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff8b8260c8ef16ad, []int{3}
}

func (m *UnloadOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnloadOperation.Unmarshal(m, b)
}
func (m *UnloadOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnloadOperation.Marshal(b, m, deterministic)
}
func (m *UnloadOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnloadOperation.Merge(m, src)
}
func (m *UnloadOperation) XXX_Size() int {
	return xxx_messageInfo_UnloadOperation.Size(m)
}
func (m *UnloadOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_UnloadOperation.DiscardUnknown(m)
}

var xxx_messageInfo_UnloadOperation proto.InternalMessageInfo

func (m *UnloadOperation) GetConversation() *Conversation {
	if m != nil {
		return m.Conversation
	}
	return nil
}

func (m *UnloadOperation) GetTray() *Tray {
	if m != nil {
		return m.Tray
	}
	return nil
}

func (m *UnloadOperation) GetState() *UnloadOperationStateAndStatus {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *UnloadOperation) GetAck() bool {
	if m != nil {
		return m.Ack
	}
	return false
}

func (m *UnloadOperation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *UnloadOperation) GetResults() *ProcessResults {
	if m != nil {
		return m.Results
	}
	return nil
}

// TerminalAlarm describes equipment alarms and is used to communicate alarms from Terminal to conductor and to acknowledge
// to Terminal at the application layer, that Conductor has processed the alarm event.
type TerminalAlarm struct {
	Conversation *Conversation `protobuf:"bytes,1,opt,name=conversation,proto3" json:"conversation,omitempty"`
	// Location associated with alarm, if any.
	Location *Location `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// status of the alarm
	Status AlarmStatus `protobuf:"varint,3,opt,name=status,proto3,enum=result.AlarmStatus" json:"status,omitempty"`
	// id is the unique identity of the alarm instance and is a namespace managed by Terminal instance. The lifecycle
	// of the id should be one round through set to clear. A new instance would get a new id once it is cleared.
	Id string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// free form alarm description (e.g. rendered in UI, logs, etc)
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// Alarm level determined by Terminal.
	Level                AlarmLevel           `protobuf:"varint,6,opt,name=level,proto3,enum=result.AlarmLevel" json:"level,omitempty"`
	Start                *timestamp.Timestamp `protobuf:"bytes,7,opt,name=start,proto3" json:"start,omitempty"`
	Release              *timestamp.Timestamp `protobuf:"bytes,8,opt,name=release,proto3" json:"release,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TerminalAlarm) Reset()         { *m = TerminalAlarm{} }
func (m *TerminalAlarm) String() string { return proto.CompactTextString(m) }
func (*TerminalAlarm) ProtoMessage()    {}
func (*TerminalAlarm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff8b8260c8ef16ad, []int{4}
}

func (m *TerminalAlarm) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TerminalAlarm.Unmarshal(m, b)
}
func (m *TerminalAlarm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TerminalAlarm.Marshal(b, m, deterministic)
}
func (m *TerminalAlarm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TerminalAlarm.Merge(m, src)
}
func (m *TerminalAlarm) XXX_Size() int {
	return xxx_messageInfo_TerminalAlarm.Size(m)
}
func (m *TerminalAlarm) XXX_DiscardUnknown() {
	xxx_messageInfo_TerminalAlarm.DiscardUnknown(m)
}

var xxx_messageInfo_TerminalAlarm proto.InternalMessageInfo

func (m *TerminalAlarm) GetConversation() *Conversation {
	if m != nil {
		return m.Conversation
	}
	return nil
}

func (m *TerminalAlarm) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *TerminalAlarm) GetStatus() AlarmStatus {
	if m != nil {
		return m.Status
	}
	return AlarmStatus_Clear
}

func (m *TerminalAlarm) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TerminalAlarm) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TerminalAlarm) GetLevel() AlarmLevel {
	if m != nil {
		return m.Level
	}
	return AlarmLevel_Warning
}

func (m *TerminalAlarm) GetStart() *timestamp.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *TerminalAlarm) GetRelease() *timestamp.Timestamp {
	if m != nil {
		return m.Release
	}
	return nil
}

func init() {
	proto.RegisterEnum("LoadOperationState", LoadOperationState_name, LoadOperationState_value)
	proto.RegisterEnum("UnloadOperationState", UnloadOperationState_name, UnloadOperationState_value)
	proto.RegisterType((*LoadOperationStateAndStatus)(nil), "LoadOperationStateAndStatus")
	proto.RegisterType((*LoadOperation)(nil), "LoadOperation")
	proto.RegisterType((*UnloadOperationStateAndStatus)(nil), "UnloadOperationStateAndStatus")
	proto.RegisterType((*UnloadOperation)(nil), "UnloadOperation")
	proto.RegisterType((*TerminalAlarm)(nil), "TerminalAlarm")
}

func init() { proto.RegisterFile("terminal.proto", fileDescriptor_ff8b8260c8ef16ad) }

var fileDescriptor_ff8b8260c8ef16ad = []byte{
	// 666 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0xdd, 0xd6, 0x4d, 0x27, 0xad, 0x71, 0xb7, 0x05, 0xac, 0xf0, 0x17, 0x45, 0x08, 0x85,
	0x56, 0x72, 0x23, 0x53, 0x71, 0xea, 0xa5, 0xfc, 0x89, 0x43, 0x05, 0xd5, 0x12, 0x2e, 0x1c, 0x40,
	0x5b, 0x7b, 0xa8, 0x2c, 0x1c, 0xaf, 0xb5, 0xbb, 0xa9, 0xf0, 0x73, 0xf0, 0x04, 0x70, 0xe0, 0xd1,
	0x38, 0xf3, 0x08, 0x68, 0xd7, 0x76, 0xb1, 0x93, 0x2a, 0x20, 0xf1, 0x73, 0xca, 0xce, 0xcc, 0x37,
	0x3b, 0x9f, 0xbf, 0x6f, 0x77, 0x03, 0xae, 0x42, 0x31, 0x49, 0x32, 0x96, 0x06, 0xb9, 0xe0, 0x8a,
	0xf7, 0xbc, 0x88, 0x67, 0x19, 0x46, 0x2a, 0xe1, 0x59, 0x23, 0x73, 0x8e, 0x05, 0xcb, 0x22, 0xac,
	0x32, 0x1b, 0x02, 0xa3, 0x24, 0x6f, 0x44, 0x72, 0x9a, 0xaa, 0x2a, 0xba, 0x73, 0xc6, 0xf9, 0x59,
	0x8a, 0xfb, 0x26, 0x3a, 0x9d, 0xbe, 0xdf, 0x57, 0xc9, 0x04, 0xa5, 0x62, 0x93, 0xbc, 0x04, 0x0c,
	0xbe, 0x58, 0x70, 0xe3, 0x98, 0xb3, 0xf8, 0x65, 0x8e, 0x82, 0xe9, 0x31, 0xaf, 0x14, 0x53, 0x78,
	0x94, 0xc5, 0xfa, 0x77, 0x2a, 0xc9, 0x7d, 0x58, 0x95, 0x3a, 0xe3, 0x5b, 0x7d, 0x6b, 0xe8, 0x86,
	0xdb, 0xc1, 0x3c, 0x98, 0x96, 0x08, 0x32, 0x02, 0x30, 0x8b, 0x77, 0xaa, 0xc8, 0xd1, 0xb7, 0x0d,
	0x7e, 0x2b, 0xa8, 0xe8, 0x18, 0xe4, 0xb8, 0xc8, 0x91, 0xae, 0xcb, 0x7a, 0x49, 0xee, 0x81, 0x23,
	0xcd, 0x18, 0x7f, 0xb9, 0x6f, 0x0d, 0xbb, 0xa1, 0xdb, 0x44, 0x4f, 0x25, 0xad, 0xaa, 0x83, 0x4f,
	0x36, 0x6c, 0xb6, 0xe6, 0x92, 0x43, 0xd8, 0x30, 0x3a, 0x08, 0x69, 0x62, 0xc3, 0xae, 0x1b, 0xfa,
	0x41, 0x43, 0xae, 0xc7, 0x8d, 0x3a, 0x6d, 0xa1, 0xc9, 0x5d, 0x58, 0x51, 0x82, 0x15, 0x86, 0x63,
	0x37, 0xf4, 0x82, 0x86, 0xa4, 0x63, 0xc1, 0x0a, 0x6a, 0xaa, 0x24, 0xac, 0x3f, 0xbd, 0x24, 0x77,
	0x33, 0x58, 0xa0, 0x53, 0xad, 0x81, 0x07, 0xcb, 0x2c, 0xfa, 0xe0, 0xaf, 0xf4, 0xad, 0x61, 0x87,
	0xea, 0x25, 0x19, 0x41, 0x27, 0xe5, 0x51, 0xc9, 0x72, 0xd5, 0x6c, 0xb4, 0xd3, 0x9c, 0x77, 0x5c,
	0xd5, 0xe8, 0x05, 0x4a, 0xab, 0x52, 0x3a, 0xea, 0x3b, 0x17, 0xaa, 0x18, 0x83, 0xa9, 0xf9, 0xa1,
	0x55, 0x75, 0xf0, 0xd5, 0x82, 0x5b, 0xaf, 0xb3, 0x74, 0x81, 0x79, 0x7b, 0x6d, 0xf3, 0xae, 0x06,
	0x97, 0xc1, 0xff, 0xbd, 0x7d, 0x9f, 0x6d, 0xb8, 0x32, 0x33, 0xf9, 0xbf, 0x18, 0x78, 0xd0, 0x36,
	0xf0, 0x76, 0xb0, 0x50, 0xad, 0xbf, 0x69, 0xe1, 0x08, 0xd6, 0x4a, 0x29, 0x64, 0xe5, 0xe1, 0xb5,
	0x5a, 0x9a, 0x13, 0xc1, 0x23, 0x94, 0x92, 0x96, 0x55, 0x5a, 0xc3, 0x06, 0xdf, 0x6d, 0xd8, 0x1c,
	0x57, 0x77, 0xff, 0x28, 0x65, 0x62, 0xf2, 0x87, 0x0a, 0x35, 0x39, 0xdb, 0xbf, 0xc5, 0x79, 0xaf,
	0xe5, 0xa6, 0xbe, 0xea, 0x15, 0x65, 0x43, 0xa7, 0x6d, 0x29, 0x71, 0xc1, 0x4e, 0x62, 0xa3, 0xd1,
	0x3a, 0xb5, 0x93, 0x98, 0xf4, 0xa1, 0x1b, 0xa3, 0x8c, 0x44, 0x92, 0x5f, 0xa8, 0xb4, 0x4e, 0x9b,
	0x29, 0x32, 0x84, 0xd5, 0x14, 0xcf, 0x31, 0x35, 0x82, 0xb8, 0x21, 0x69, 0xed, 0x7e, 0xac, 0x2b,
	0xb4, 0x04, 0x90, 0x91, 0xb1, 0x4d, 0x28, 0x7f, 0xcd, 0xf0, 0xee, 0x05, 0xe5, 0x1b, 0x16, 0xd4,
	0x6f, 0x58, 0x30, 0xae, 0xdf, 0x30, 0x5a, 0x02, 0xc9, 0x81, 0x96, 0x3b, 0x45, 0x26, 0xd1, 0xef,
	0xfc, 0xb2, 0xa7, 0x86, 0xee, 0x46, 0x40, 0xe6, 0x6f, 0x34, 0x21, 0xe0, 0xbe, 0xe0, 0x8a, 0x22,
	0x8b, 0x8b, 0x31, 0xd7, 0x75, 0x6f, 0x89, 0x5c, 0x87, 0xed, 0x13, 0x81, 0x39, 0x13, 0x18, 0x3f,
	0xe3, 0xe2, 0x09, 0xa6, 0xc9, 0x39, 0x8a, 0xc2, 0xb3, 0xc8, 0x0e, 0x78, 0x75, 0x61, 0xcc, 0x8f,
	0xa2, 0x08, 0x73, 0xe5, 0xd9, 0x04, 0xc0, 0xd1, 0x8d, 0x18, 0x7b, 0xcb, 0xbb, 0x6f, 0x61, 0xe7,
	0xb2, 0x53, 0xa7, 0x3b, 0x7f, 0x8e, 0x29, 0x11, 0xde, 0x12, 0xd9, 0x80, 0xce, 0xd3, 0x8f, 0x18,
	0x4d, 0x15, 0xc6, 0xb3, 0xbb, 0x57, 0x18, 0x5b, 0x63, 0xca, 0xb5, 0xde, 0x3f, 0xfc, 0x66, 0x41,
	0xa7, 0xfe, 0xcf, 0x20, 0x0f, 0xc1, 0x6d, 0x7d, 0x91, 0x24, 0x6e, 0xfb, 0xd1, 0xea, 0xcd, 0xc4,
	0x83, 0xa5, 0xa1, 0x35, 0xb2, 0xc8, 0x21, 0x78, 0x33, 0x24, 0x25, 0xf1, 0x66, 0x6f, 0x4b, 0x6f,
	0x2e, 0x53, 0x75, 0x07, 0xe0, 0x18, 0x13, 0xf5, 0xb4, 0xd6, 0x11, 0xee, 0xcd, 0xc4, 0x15, 0xfe,
	0x00, 0x9c, 0xe7, 0x98, 0xa6, 0x5c, 0x92, 0xad, 0xe6, 0x61, 0x36, 0xb9, 0xde, 0x7c, 0xaa, 0xec,
	0x7a, 0xe4, 0xbc, 0x59, 0x61, 0x52, 0xc8, 0x53, 0xc7, 0x58, 0xfa, 0xe0, 0x47, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x8a, 0x18, 0x0e, 0xd6, 0x2a, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TerminalClient is the client API for Terminal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TerminalClient interface {
	// LoadOperations provides a bidirectional stream between Conductor as client, and Terminal as server and provides
	// for the exchange of messages required to coordinate loading of payload into a Terminal location and requesting
	// execution of task in recipe step.
	LoadOperations(ctx context.Context, opts ...grpc.CallOption) (Terminal_LoadOperationsClient, error)
	// UnloadOperations provides a bidirectional stream between Conductor as client, and Terminal as server and provides
	// for the exchange of messages required to coordinate unloading of payload from Terminal location and collecting
	// results from execution of task.
	UnloadOperations(ctx context.Context, opts ...grpc.CallOption) (Terminal_UnloadOperationsClient, error)
	// Alarms are server side streamed from Terminal to conductor using this service. The client side will return the alarm
	// in the client side stream as shown as an acknowledgement of the fault.
	Alarms(ctx context.Context, opts ...grpc.CallOption) (Terminal_AlarmsClient, error)
	// Hello service allows each end (client and server) to initiate an application level short exchange of hello
	// messages. Each end can control whether and how often it wishes to validate the roundtrip to the other endpoint.
	// When it wishes to do so, it would launch a Hello message in the stream with echo_request set to true, and nonce set
	// to a random number. The other end, when receiving a message with echo_request set to true, must reply in a timely
	// way with echo_request set to false and nonce copied from the original request.
	Hellos(ctx context.Context, opts ...grpc.CallOption) (Terminal_HellosClient, error)
}

type terminalClient struct {
	cc *grpc.ClientConn
}

func NewTerminalClient(cc *grpc.ClientConn) TerminalClient {
	return &terminalClient{cc}
}

func (c *terminalClient) LoadOperations(ctx context.Context, opts ...grpc.CallOption) (Terminal_LoadOperationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Terminal_serviceDesc.Streams[0], "/terminal/LoadOperations", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalLoadOperationsClient{stream}
	return x, nil
}

type Terminal_LoadOperationsClient interface {
	Send(*LoadOperation) error
	Recv() (*LoadOperation, error)
	grpc.ClientStream
}

type terminalLoadOperationsClient struct {
	grpc.ClientStream
}

func (x *terminalLoadOperationsClient) Send(m *LoadOperation) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalLoadOperationsClient) Recv() (*LoadOperation, error) {
	m := new(LoadOperation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalClient) UnloadOperations(ctx context.Context, opts ...grpc.CallOption) (Terminal_UnloadOperationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Terminal_serviceDesc.Streams[1], "/terminal/UnloadOperations", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalUnloadOperationsClient{stream}
	return x, nil
}

type Terminal_UnloadOperationsClient interface {
	Send(*UnloadOperation) error
	Recv() (*UnloadOperation, error)
	grpc.ClientStream
}

type terminalUnloadOperationsClient struct {
	grpc.ClientStream
}

func (x *terminalUnloadOperationsClient) Send(m *UnloadOperation) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalUnloadOperationsClient) Recv() (*UnloadOperation, error) {
	m := new(UnloadOperation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalClient) Alarms(ctx context.Context, opts ...grpc.CallOption) (Terminal_AlarmsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Terminal_serviceDesc.Streams[2], "/terminal/Alarms", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalAlarmsClient{stream}
	return x, nil
}

type Terminal_AlarmsClient interface {
	Send(*TerminalAlarm) error
	Recv() (*TerminalAlarm, error)
	grpc.ClientStream
}

type terminalAlarmsClient struct {
	grpc.ClientStream
}

func (x *terminalAlarmsClient) Send(m *TerminalAlarm) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalAlarmsClient) Recv() (*TerminalAlarm, error) {
	m := new(TerminalAlarm)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalClient) Hellos(ctx context.Context, opts ...grpc.CallOption) (Terminal_HellosClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Terminal_serviceDesc.Streams[3], "/terminal/Hellos", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalHellosClient{stream}
	return x, nil
}

type Terminal_HellosClient interface {
	Send(*Hello) error
	Recv() (*Hello, error)
	grpc.ClientStream
}

type terminalHellosClient struct {
	grpc.ClientStream
}

func (x *terminalHellosClient) Send(m *Hello) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalHellosClient) Recv() (*Hello, error) {
	m := new(Hello)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TerminalServer is the server API for Terminal service.
type TerminalServer interface {
	// LoadOperations provides a bidirectional stream between Conductor as client, and Terminal as server and provides
	// for the exchange of messages required to coordinate loading of payload into a Terminal location and requesting
	// execution of task in recipe step.
	LoadOperations(Terminal_LoadOperationsServer) error
	// UnloadOperations provides a bidirectional stream between Conductor as client, and Terminal as server and provides
	// for the exchange of messages required to coordinate unloading of payload from Terminal location and collecting
	// results from execution of task.
	UnloadOperations(Terminal_UnloadOperationsServer) error
	// Alarms are server side streamed from Terminal to conductor using this service. The client side will return the alarm
	// in the client side stream as shown as an acknowledgement of the fault.
	Alarms(Terminal_AlarmsServer) error
	// Hello service allows each end (client and server) to initiate an application level short exchange of hello
	// messages. Each end can control whether and how often it wishes to validate the roundtrip to the other endpoint.
	// When it wishes to do so, it would launch a Hello message in the stream with echo_request set to true, and nonce set
	// to a random number. The other end, when receiving a message with echo_request set to true, must reply in a timely
	// way with echo_request set to false and nonce copied from the original request.
	Hellos(Terminal_HellosServer) error
}

func RegisterTerminalServer(s *grpc.Server, srv TerminalServer) {
	s.RegisterService(&_Terminal_serviceDesc, srv)
}

func _Terminal_LoadOperations_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalServer).LoadOperations(&terminalLoadOperationsServer{stream})
}

type Terminal_LoadOperationsServer interface {
	Send(*LoadOperation) error
	Recv() (*LoadOperation, error)
	grpc.ServerStream
}

type terminalLoadOperationsServer struct {
	grpc.ServerStream
}

func (x *terminalLoadOperationsServer) Send(m *LoadOperation) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalLoadOperationsServer) Recv() (*LoadOperation, error) {
	m := new(LoadOperation)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Terminal_UnloadOperations_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalServer).UnloadOperations(&terminalUnloadOperationsServer{stream})
}

type Terminal_UnloadOperationsServer interface {
	Send(*UnloadOperation) error
	Recv() (*UnloadOperation, error)
	grpc.ServerStream
}

type terminalUnloadOperationsServer struct {
	grpc.ServerStream
}

func (x *terminalUnloadOperationsServer) Send(m *UnloadOperation) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalUnloadOperationsServer) Recv() (*UnloadOperation, error) {
	m := new(UnloadOperation)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Terminal_Alarms_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalServer).Alarms(&terminalAlarmsServer{stream})
}

type Terminal_AlarmsServer interface {
	Send(*TerminalAlarm) error
	Recv() (*TerminalAlarm, error)
	grpc.ServerStream
}

type terminalAlarmsServer struct {
	grpc.ServerStream
}

func (x *terminalAlarmsServer) Send(m *TerminalAlarm) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalAlarmsServer) Recv() (*TerminalAlarm, error) {
	m := new(TerminalAlarm)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Terminal_Hellos_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalServer).Hellos(&terminalHellosServer{stream})
}

type Terminal_HellosServer interface {
	Send(*Hello) error
	Recv() (*Hello, error)
	grpc.ServerStream
}

type terminalHellosServer struct {
	grpc.ServerStream
}

func (x *terminalHellosServer) Send(m *Hello) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalHellosServer) Recv() (*Hello, error) {
	m := new(Hello)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Terminal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "terminal",
	HandlerType: (*TerminalServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LoadOperations",
			Handler:       _Terminal_LoadOperations_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UnloadOperations",
			Handler:       _Terminal_UnloadOperations_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Alarms",
			Handler:       _Terminal_Alarms_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Hellos",
			Handler:       _Terminal_Hellos_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "terminal.proto",
}
