// Code generated by protoc-gen-go. DO NOT EDIT.
// source: asrs.proto

package asrs

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MaterialFlowOperationState int32

const (
	MaterialFlowOperationState_UnusedMaterialFlowOperationState MaterialFlowOperationState = 0
	// ReadyToPlace represents system poised to place a tray at a location.
	MaterialFlowOperationState_ReadyToPlace MaterialFlowOperationState = 1
	// Placed indicates that a tray has been placed at a location.
	MaterialFlowOperationState_Placed MaterialFlowOperationState = 2
	// ReadyToPick indicates system poised to pick up a tray at a location.
	MaterialFlowOperationState_ReadyToPick MaterialFlowOperationState = 3
	// Picked indicates system having picked a tray at a location.
	MaterialFlowOperationState_Picked MaterialFlowOperationState = 4
	// RecipeComplete indicates that whatever recipe was scheduled to operate at a location is now complete.
	MaterialFlowOperationState_RecipeComplete MaterialFlowOperationState = 5
)

var MaterialFlowOperationState_name = map[int32]string{
	0: "UnusedMaterialFlowOperationState",
	1: "ReadyToPlace",
	2: "Placed",
	3: "ReadyToPick",
	4: "Picked",
	5: "RecipeComplete",
}

var MaterialFlowOperationState_value = map[string]int32{
	"UnusedMaterialFlowOperationState": 0,
	"ReadyToPlace":                     1,
	"Placed":                           2,
	"ReadyToPick":                      3,
	"Picked":                           4,
	"RecipeComplete":                   5,
}

func (x MaterialFlowOperationState) String() string {
	return proto.EnumName(MaterialFlowOperationState_name, int32(x))
}

func (MaterialFlowOperationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{0}
}

// State of the operation to mitigate urgent event.
type UrgentEventOperationState int32

const (
	UrgentEventOperationState_UnusedUrgentOperationState UrgentEventOperationState = 0
	// Deployed indicates equipment at location ready to mitigate event (e.g. crane with fire extinguisher at location ready to extinguish)
	UrgentEventOperationState_Deployed UrgentEventOperationState = 1
	// Mitigating indicates the equipment actively attempting to mitigate urgent event (e.g crane is employing fire extinguisher)
	UrgentEventOperationState_Mitigating UrgentEventOperationState = 2
	// Released indicates equipment returned to normal duty.
	UrgentEventOperationState_Released UrgentEventOperationState = 3
)

var UrgentEventOperationState_name = map[int32]string{
	0: "UnusedUrgentOperationState",
	1: "Deployed",
	2: "Mitigating",
	3: "Released",
}

var UrgentEventOperationState_value = map[string]int32{
	"UnusedUrgentOperationState": 0,
	"Deployed":                   1,
	"Mitigating":                 2,
	"Released":                   3,
}

func (x UrgentEventOperationState) String() string {
	return proto.EnumName(UrgentEventOperationState_name, int32(x))
}

func (UrgentEventOperationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{1}
}

// Type of mitigation required for urgent event.
type UrgentEvent_Mitigation int32

const (
	UrgentEvent_UnusedMitigation UrgentEvent_Mitigation = 0
	UrgentEvent_FireSuppression  UrgentEvent_Mitigation = 1
)

var UrgentEvent_Mitigation_name = map[int32]string{
	0: "UnusedMitigation",
	1: "FireSuppression",
}

var UrgentEvent_Mitigation_value = map[string]int32{
	"UnusedMitigation": 0,
	"FireSuppression":  1,
}

func (x UrgentEvent_Mitigation) String() string {
	return proto.EnumName(UrgentEvent_Mitigation_name, int32(x))
}

func (UrgentEvent_Mitigation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{2, 0}
}

// Which subcomponent of WMS is the subject of this alarm.
type WMSAlarm_SubComponent int32

const (
	WMSAlarm_Stacker  WMSAlarm_SubComponent = 0
	WMSAlarm_Conveyor WMSAlarm_SubComponent = 1
)

var WMSAlarm_SubComponent_name = map[int32]string{
	0: "Stacker",
	1: "Conveyor",
}

var WMSAlarm_SubComponent_value = map[string]int32{
	"Stacker":  0,
	"Conveyor": 1,
}

func (x WMSAlarm_SubComponent) String() string {
	return proto.EnumName(WMSAlarm_SubComponent_name, int32(x))
}

func (WMSAlarm_SubComponent) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{5, 0}
}

// A State and Status combo for material operation state; status described whether we have successfully
// completed the transition into the state, or whether the internal state machine for the state is faulted.
type MaterialFlowStateAndStatus struct {
	State MaterialFlowOperationState `protobuf:"varint,1,opt,name=state,proto3,enum=asrs.MaterialFlowOperationState" json:"state,omitempty"`
	// Is this state conveying a desired state or actual state
	StateType StateType `protobuf:"varint,2,opt,name=state_type,json=stateType,proto3,enum=result.StateType" json:"state_type,omitempty"`
	// Status indicates whether state transition completed successfully or faulted.
	Status               *Status  `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaterialFlowStateAndStatus) Reset()         { *m = MaterialFlowStateAndStatus{} }
func (m *MaterialFlowStateAndStatus) String() string { return proto.CompactTextString(m) }
func (*MaterialFlowStateAndStatus) ProtoMessage()    {}
func (*MaterialFlowStateAndStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{0}
}

func (m *MaterialFlowStateAndStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MaterialFlowStateAndStatus.Unmarshal(m, b)
}
func (m *MaterialFlowStateAndStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MaterialFlowStateAndStatus.Marshal(b, m, deterministic)
}
func (m *MaterialFlowStateAndStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterialFlowStateAndStatus.Merge(m, src)
}
func (m *MaterialFlowStateAndStatus) XXX_Size() int {
	return xxx_messageInfo_MaterialFlowStateAndStatus.Size(m)
}
func (m *MaterialFlowStateAndStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterialFlowStateAndStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MaterialFlowStateAndStatus proto.InternalMessageInfo

func (m *MaterialFlowStateAndStatus) GetState() MaterialFlowOperationState {
	if m != nil {
		return m.State
	}
	return MaterialFlowOperationState_UnusedMaterialFlowOperationState
}

func (m *MaterialFlowStateAndStatus) GetStateType() StateType {
	if m != nil {
		return m.StateType
	}
	return StateType_UnusedStateType
}

func (m *MaterialFlowStateAndStatus) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// MaterialFlowOperation is used as follows:
// WMS -> Conduction to indicate current state
// Conductor -> WMS to indicate desired state or acknowledgment of current state.
// Current and Acknowledged state embed status (where faults may be indicated).
type MaterialFlowOperation struct {
	Conversation *Conversation `protobuf:"bytes,1,opt,name=conversation,proto3" json:"conversation,omitempty"`
	Tray         *Tray         `protobuf:"bytes,2,opt,name=tray,proto3" json:"tray,omitempty"`
	// state indicates the desired or current state and status.
	State *MaterialFlowStateAndStatus `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// ack indicates whether this message is acknowledging a current or desired state.
	Ack      bool      `protobuf:"varint,4,opt,name=ack,proto3" json:"ack,omitempty"`
	Location *Location `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
	// When conveying a move, destination describes a destination endpoint.
	Destination *Location `protobuf:"bytes,6,opt,name=destination,proto3" json:"destination,omitempty"`
	// Embed one of any type of recipe. Recipe describe where the payload is in the process and what process is about
	// to be applied at the next step.
	Recipe               *Recipe  `protobuf:"bytes,7,opt,name=recipe,proto3" json:"recipe,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaterialFlowOperation) Reset()         { *m = MaterialFlowOperation{} }
func (m *MaterialFlowOperation) String() string { return proto.CompactTextString(m) }
func (*MaterialFlowOperation) ProtoMessage()    {}
func (*MaterialFlowOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{1}
}

func (m *MaterialFlowOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MaterialFlowOperation.Unmarshal(m, b)
}
func (m *MaterialFlowOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MaterialFlowOperation.Marshal(b, m, deterministic)
}
func (m *MaterialFlowOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterialFlowOperation.Merge(m, src)
}
func (m *MaterialFlowOperation) XXX_Size() int {
	return xxx_messageInfo_MaterialFlowOperation.Size(m)
}
func (m *MaterialFlowOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterialFlowOperation.DiscardUnknown(m)
}

var xxx_messageInfo_MaterialFlowOperation proto.InternalMessageInfo

func (m *MaterialFlowOperation) GetConversation() *Conversation {
	if m != nil {
		return m.Conversation
	}
	return nil
}

func (m *MaterialFlowOperation) GetTray() *Tray {
	if m != nil {
		return m.Tray
	}
	return nil
}

func (m *MaterialFlowOperation) GetState() *MaterialFlowStateAndStatus {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *MaterialFlowOperation) GetAck() bool {
	if m != nil {
		return m.Ack
	}
	return false
}

func (m *MaterialFlowOperation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *MaterialFlowOperation) GetDestination() *Location {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *MaterialFlowOperation) GetRecipe() *Recipe {
	if m != nil {
		return m.Recipe
	}
	return nil
}

// UrgentEvent describes a location, time and type of an event which typically requires urgent mitigation.
type UrgentEvent struct {
	// Location of UrgentEvent
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// Timestamp when urgent event was detected. This can be used as the identity of the event.
	Timestamp            *timestamp.Timestamp   `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	MitigationType       UrgentEvent_Mitigation `protobuf:"varint,3,opt,name=mitigation_type,json=mitigationType,proto3,enum=asrs.UrgentEvent_Mitigation" json:"mitigation_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UrgentEvent) Reset()         { *m = UrgentEvent{} }
func (m *UrgentEvent) String() string { return proto.CompactTextString(m) }
func (*UrgentEvent) ProtoMessage()    {}
func (*UrgentEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{2}
}

func (m *UrgentEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UrgentEvent.Unmarshal(m, b)
}
func (m *UrgentEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UrgentEvent.Marshal(b, m, deterministic)
}
func (m *UrgentEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrgentEvent.Merge(m, src)
}
func (m *UrgentEvent) XXX_Size() int {
	return xxx_messageInfo_UrgentEvent.Size(m)
}
func (m *UrgentEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UrgentEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UrgentEvent proto.InternalMessageInfo

func (m *UrgentEvent) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *UrgentEvent) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *UrgentEvent) GetMitigationType() UrgentEvent_Mitigation {
	if m != nil {
		return m.MitigationType
	}
	return UrgentEvent_UnusedMitigation
}

type UrgentEventOperationStateAndStatus struct {
	State UrgentEventOperationState `protobuf:"varint,1,opt,name=state,proto3,enum=asrs.UrgentEventOperationState" json:"state,omitempty"`
	// Is this state conveying a desired state or actual state
	StateType StateType `protobuf:"varint,2,opt,name=state_type,json=stateType,proto3,enum=result.StateType" json:"state_type,omitempty"`
	// Status describes whether we completed transition to state of faulted.
	Status               *Status  `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrgentEventOperationStateAndStatus) Reset()         { *m = UrgentEventOperationStateAndStatus{} }
func (m *UrgentEventOperationStateAndStatus) String() string { return proto.CompactTextString(m) }
func (*UrgentEventOperationStateAndStatus) ProtoMessage()    {}
func (*UrgentEventOperationStateAndStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{3}
}

func (m *UrgentEventOperationStateAndStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UrgentEventOperationStateAndStatus.Unmarshal(m, b)
}
func (m *UrgentEventOperationStateAndStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UrgentEventOperationStateAndStatus.Marshal(b, m, deterministic)
}
func (m *UrgentEventOperationStateAndStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrgentEventOperationStateAndStatus.Merge(m, src)
}
func (m *UrgentEventOperationStateAndStatus) XXX_Size() int {
	return xxx_messageInfo_UrgentEventOperationStateAndStatus.Size(m)
}
func (m *UrgentEventOperationStateAndStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UrgentEventOperationStateAndStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UrgentEventOperationStateAndStatus proto.InternalMessageInfo

func (m *UrgentEventOperationStateAndStatus) GetState() UrgentEventOperationState {
	if m != nil {
		return m.State
	}
	return UrgentEventOperationState_UnusedUrgentOperationState
}

func (m *UrgentEventOperationStateAndStatus) GetStateType() StateType {
	if m != nil {
		return m.StateType
	}
	return StateType_UnusedStateType
}

func (m *UrgentEventOperationStateAndStatus) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// UrgentEventOperation represents operation associated with an event which requires urgent mitigation (e.g. smoke
// is detected and we need to deploy fire suppressing equipment urgently).
//
// UrgentEventOperations are sent from Conductor to WMS indicating a desired state; e.g. Deployed,
// Mitigating and Released.
//
// UrgentEventOperations are sent from WMS to Conductor to keep Conductor informed of where WMS is in the process of
// mitigating the urgent event (e.g. deploying fire suppression equipment to location or extinguishing).
type UrgentEventOperation struct {
	Conversation *Conversation `protobuf:"bytes,1,opt,name=conversation,proto3" json:"conversation,omitempty"`
	// Description of urgent event requiring attention.
	Event *UrgentEvent `protobuf:"bytes,2,opt,name=event,proto3" json:"event,omitempty"`
	// state indicates the desired or current state and status.
	State *UrgentEventOperationStateAndStatus `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// ack indicates whether this message is acknowledging a current or desired state.
	Ack                  bool     `protobuf:"varint,4,opt,name=ack,proto3" json:"ack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrgentEventOperation) Reset()         { *m = UrgentEventOperation{} }
func (m *UrgentEventOperation) String() string { return proto.CompactTextString(m) }
func (*UrgentEventOperation) ProtoMessage()    {}
func (*UrgentEventOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{4}
}

func (m *UrgentEventOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UrgentEventOperation.Unmarshal(m, b)
}
func (m *UrgentEventOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UrgentEventOperation.Marshal(b, m, deterministic)
}
func (m *UrgentEventOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrgentEventOperation.Merge(m, src)
}
func (m *UrgentEventOperation) XXX_Size() int {
	return xxx_messageInfo_UrgentEventOperation.Size(m)
}
func (m *UrgentEventOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_UrgentEventOperation.DiscardUnknown(m)
}

var xxx_messageInfo_UrgentEventOperation proto.InternalMessageInfo

func (m *UrgentEventOperation) GetConversation() *Conversation {
	if m != nil {
		return m.Conversation
	}
	return nil
}

func (m *UrgentEventOperation) GetEvent() *UrgentEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *UrgentEventOperation) GetState() *UrgentEventOperationStateAndStatus {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *UrgentEventOperation) GetAck() bool {
	if m != nil {
		return m.Ack
	}
	return false
}

// WSMAlarm describes WMS-side alarms and is used to communicate alarms from WMS to conductor and to acknowledge
// to WMS at the application layer, that Conductor has processed the alarm event.
type WMSAlarm struct {
	Conversation *Conversation         `protobuf:"bytes,1,opt,name=conversation,proto3" json:"conversation,omitempty"`
	SubComponent WMSAlarm_SubComponent `protobuf:"varint,2,opt,name=sub_component,json=subComponent,proto3,enum=asrs.WMSAlarm_SubComponent" json:"sub_component,omitempty"`
	// instance reflects which device the alarm is related to. e.g. conveyor site number, stacker number
	// MIGRATION: instance is a replacement for WMS_NUM
	Instance string      `protobuf:"bytes,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Status   AlarmStatus `protobuf:"varint,4,opt,name=status,proto3,enum=result.AlarmStatus" json:"status,omitempty"`
	// id is the unique identity of the alarm instance and it a namespace managed by the WMS instance. The lifecycle
	// of the id should be one round through set to clear. A new instance would get a new id once it is cleared.
	Id string `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	// free form alarm description
	// MIGRATION: description replaces ALTX
	Description          string               `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Level                AlarmLevel           `protobuf:"varint,7,opt,name=level,proto3,enum=result.AlarmLevel" json:"level,omitempty"`
	Start                *timestamp.Timestamp `protobuf:"bytes,8,opt,name=start,proto3" json:"start,omitempty"`
	Release              *timestamp.Timestamp `protobuf:"bytes,9,opt,name=release,proto3" json:"release,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *WMSAlarm) Reset()         { *m = WMSAlarm{} }
func (m *WMSAlarm) String() string { return proto.CompactTextString(m) }
func (*WMSAlarm) ProtoMessage()    {}
func (*WMSAlarm) Descriptor() ([]byte, []int) {
	return fileDescriptor_73b859764e08b9d5, []int{5}
}

func (m *WMSAlarm) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WMSAlarm.Unmarshal(m, b)
}
func (m *WMSAlarm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WMSAlarm.Marshal(b, m, deterministic)
}
func (m *WMSAlarm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WMSAlarm.Merge(m, src)
}
func (m *WMSAlarm) XXX_Size() int {
	return xxx_messageInfo_WMSAlarm.Size(m)
}
func (m *WMSAlarm) XXX_DiscardUnknown() {
	xxx_messageInfo_WMSAlarm.DiscardUnknown(m)
}

var xxx_messageInfo_WMSAlarm proto.InternalMessageInfo

func (m *WMSAlarm) GetConversation() *Conversation {
	if m != nil {
		return m.Conversation
	}
	return nil
}

func (m *WMSAlarm) GetSubComponent() WMSAlarm_SubComponent {
	if m != nil {
		return m.SubComponent
	}
	return WMSAlarm_Stacker
}

func (m *WMSAlarm) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func (m *WMSAlarm) GetStatus() AlarmStatus {
	if m != nil {
		return m.Status
	}
	return AlarmStatus_Clear
}

func (m *WMSAlarm) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *WMSAlarm) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *WMSAlarm) GetLevel() AlarmLevel {
	if m != nil {
		return m.Level
	}
	return AlarmLevel_Warning
}

func (m *WMSAlarm) GetStart() *timestamp.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *WMSAlarm) GetRelease() *timestamp.Timestamp {
	if m != nil {
		return m.Release
	}
	return nil
}

func init() {
	proto.RegisterEnum("asrs.MaterialFlowOperationState", MaterialFlowOperationState_name, MaterialFlowOperationState_value)
	proto.RegisterEnum("asrs.UrgentEventOperationState", UrgentEventOperationState_name, UrgentEventOperationState_value)
	proto.RegisterEnum("asrs.UrgentEvent_Mitigation", UrgentEvent_Mitigation_name, UrgentEvent_Mitigation_value)
	proto.RegisterEnum("asrs.WMSAlarm_SubComponent", WMSAlarm_SubComponent_name, WMSAlarm_SubComponent_value)
	proto.RegisterType((*MaterialFlowStateAndStatus)(nil), "asrs.MaterialFlowStateAndStatus")
	proto.RegisterType((*MaterialFlowOperation)(nil), "asrs.MaterialFlowOperation")
	proto.RegisterType((*UrgentEvent)(nil), "asrs.UrgentEvent")
	proto.RegisterType((*UrgentEventOperationStateAndStatus)(nil), "asrs.UrgentEventOperationStateAndStatus")
	proto.RegisterType((*UrgentEventOperation)(nil), "asrs.UrgentEventOperation")
	proto.RegisterType((*WMSAlarm)(nil), "asrs.WMSAlarm")
}

func init() { proto.RegisterFile("asrs.proto", fileDescriptor_73b859764e08b9d5) }

var fileDescriptor_73b859764e08b9d5 = []byte{
	// 872 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xdd, 0x8e, 0xdb, 0x44,
	0x14, 0x8e, 0xf3, 0xb7, 0xc9, 0x49, 0xea, 0x9d, 0x3d, 0xdd, 0xa2, 0xe0, 0x22, 0x1a, 0x59, 0x15,
	0x84, 0x22, 0xb9, 0xab, 0x50, 0x0a, 0x17, 0x08, 0x51, 0x4a, 0x2b, 0x2e, 0xba, 0x22, 0x9a, 0xec,
	0x0a, 0xc4, 0x4d, 0xe5, 0xb5, 0x87, 0xc8, 0x5a, 0xc7, 0xb6, 0x66, 0x26, 0x5b, 0xe5, 0x31, 0xb8,
	0xe7, 0x09, 0xb8, 0xe0, 0x8e, 0x17, 0xe0, 0x05, 0xb8, 0xe4, 0x59, 0xb8, 0x43, 0x3e, 0x63, 0x27,
	0x76, 0x37, 0xbb, 0x8b, 0xb4, 0x52, 0xaf, 0x66, 0xe6, 0x9c, 0xef, 0xcc, 0x7c, 0x73, 0xe6, 0xfb,
	0xe2, 0x00, 0xf8, 0x4a, 0x2a, 0x2f, 0x93, 0xa9, 0x4e, 0xb1, 0x9d, 0xcf, 0x1d, 0x16, 0xa4, 0x49,
	0x22, 0x02, 0x1d, 0xa5, 0x89, 0x89, 0x53, 0xe4, 0x42, 0xac, 0xfd, 0x24, 0x10, 0x45, 0x64, 0x28,
	0x45, 0x10, 0x65, 0x95, 0x95, 0x5a, 0xc5, 0xba, 0x58, 0x3d, 0x58, 0xa4, 0xe9, 0x22, 0x16, 0x8f,
	0x69, 0x75, 0xb6, 0xfa, 0xe5, 0xb1, 0x8e, 0x96, 0x42, 0x69, 0x7f, 0x99, 0x19, 0x80, 0xfb, 0x87,
	0x05, 0xce, 0xb1, 0xaf, 0x85, 0x8c, 0xfc, 0xf8, 0x65, 0x9c, 0xbe, 0x99, 0x6b, 0x5f, 0x8b, 0x67,
	0x49, 0x98, 0x8f, 0x2b, 0x85, 0x4f, 0xa1, 0xa3, 0xf2, 0xc8, 0xc8, 0x1a, 0x5b, 0x13, 0x7b, 0x3a,
	0xf6, 0x88, 0x61, 0xb5, 0xe0, 0x87, 0x4c, 0x48, 0x3f, 0xe7, 0x47, 0x95, 0xdc, 0xc0, 0xf1, 0x08,
	0x80, 0x26, 0xaf, 0xf5, 0x3a, 0x13, 0xa3, 0x26, 0x15, 0x1f, 0x78, 0x05, 0x35, 0x42, 0x9e, 0xac,
	0x33, 0xc1, 0xfb, 0xaa, 0x9c, 0xe2, 0x47, 0xd0, 0x55, 0x74, 0xe6, 0xa8, 0x35, 0xb6, 0x26, 0x83,
	0xa9, 0x5d, 0x45, 0xaf, 0x14, 0x2f, 0xb2, 0xee, 0x3f, 0x4d, 0xb8, 0xb7, 0xf3, 0x7c, 0xfc, 0x0a,
	0x86, 0xd4, 0x1b, 0xa9, 0x68, 0x4d, 0x94, 0x07, 0xd3, 0x91, 0x57, 0x69, 0xe1, 0xf3, 0x4a, 0x9e,
	0xd7, 0xd0, 0xf8, 0x10, 0xda, 0x5a, 0xfa, 0x6b, 0xe2, 0x3a, 0x98, 0x32, 0xaf, 0xd2, 0xe6, 0x13,
	0xe9, 0xaf, 0x39, 0x65, 0xb7, 0xfd, 0x30, 0x24, 0x77, 0xf4, 0xa3, 0xde, 0xc0, 0xb2, 0x1f, 0x0c,
	0x5a, 0x7e, 0x70, 0x3e, 0x6a, 0x8f, 0xad, 0x49, 0x8f, 0xe7, 0x53, 0x3c, 0x82, 0x5e, 0x9c, 0x06,
	0x86, 0x69, 0x87, 0x36, 0x3b, 0xac, 0x9e, 0xf9, 0xaa, 0xc8, 0xf1, 0x0d, 0x0a, 0x9f, 0xc2, 0x20,
	0x14, 0x4a, 0x47, 0x89, 0x29, 0xea, 0x5e, 0x53, 0x54, 0x05, 0xe6, 0x9d, 0x35, 0x0a, 0x19, 0xed,
	0x6d, 0x3a, 0x4b, 0x82, 0xe1, 0x34, 0xf0, 0x22, 0xeb, 0xfe, 0x6b, 0xc1, 0xe0, 0x54, 0x2e, 0x44,
	0xa2, 0x5f, 0x5c, 0x88, 0x44, 0xd7, 0x18, 0x5a, 0xff, 0x8b, 0xe1, 0x97, 0xd0, 0xdf, 0xe8, 0xab,
	0x68, 0xa4, 0xe3, 0x19, 0x05, 0x7a, 0xa5, 0x02, 0xbd, 0x93, 0x12, 0xc1, 0xb7, 0x60, 0x7c, 0x01,
	0xfb, 0xcb, 0x48, 0x47, 0x0b, 0xda, 0xc7, 0x88, 0xa6, 0x45, 0xa2, 0xf9, 0xc0, 0x74, 0xb8, 0xc2,
	0xcb, 0x3b, 0xde, 0x00, 0xb9, 0xbd, 0x2d, 0xca, 0x45, 0xe4, 0x7e, 0x01, 0xb0, 0xcd, 0xe2, 0x21,
	0xb0, 0xd3, 0x64, 0xa5, 0x44, 0xb8, 0x8d, 0xb1, 0x06, 0xde, 0x85, 0xfd, 0x97, 0x91, 0x14, 0xf3,
	0x55, 0x96, 0x49, 0xa1, 0x54, 0x1e, 0xb4, 0xdc, 0x3f, 0x2d, 0x70, 0x2b, 0x67, 0xd4, 0x45, 0xbd,
	0xb5, 0xc3, 0xe7, 0x75, 0x3b, 0x3c, 0xb8, 0x44, 0xee, 0x5d, 0xbb, 0xe1, 0x6f, 0x0b, 0x0e, 0x77,
	0x1d, 0x7f, 0x4b, 0x33, 0x7c, 0x0c, 0x1d, 0x91, 0xef, 0x57, 0x3c, 0xe2, 0xc1, 0xa5, 0x7b, 0x72,
	0x93, 0xc7, 0xaf, 0xeb, 0x7e, 0x98, 0xdc, 0xd0, 0x90, 0x9b, 0x7d, 0xe1, 0xfe, 0xd5, 0x82, 0xde,
	0x8f, 0xc7, 0xf3, 0x67, 0xb1, 0x2f, 0x97, 0xb7, 0xbc, 0xc5, 0x37, 0x70, 0x47, 0xad, 0xce, 0x5e,
	0x07, 0xe9, 0x32, 0x4b, 0x93, 0xf2, 0x36, 0xf6, 0xf4, 0xbe, 0x21, 0x59, 0x1e, 0xe2, 0xcd, 0x57,
	0x67, 0xcf, 0x4b, 0x08, 0x1f, 0xaa, 0xca, 0x0a, 0x1d, 0xe8, 0x45, 0x89, 0xd2, 0xb9, 0xde, 0xe9,
	0x86, 0x7d, 0xbe, 0x59, 0xe3, 0xa7, 0x9b, 0x27, 0x6a, 0xd3, 0xb6, 0x77, 0xcb, 0x27, 0xa2, 0x5d,
	0xeb, 0xef, 0x84, 0x36, 0x34, 0xa3, 0x90, 0x7c, 0xde, 0xe7, 0xcd, 0x28, 0xc4, 0x31, 0x79, 0x39,
	0x90, 0x51, 0xb6, 0xf1, 0x72, 0x9f, 0x57, 0x43, 0x38, 0x81, 0x4e, 0x2c, 0x2e, 0x44, 0x4c, 0xa6,
	0xb5, 0xa7, 0x58, 0xdb, 0xfd, 0x55, 0x9e, 0xe1, 0x06, 0x80, 0x47, 0xf4, 0x06, 0x52, 0x8f, 0x7a,
	0x37, 0x3a, 0xce, 0x00, 0xf1, 0x09, 0xec, 0x49, 0x11, 0x0b, 0x5f, 0x89, 0x51, 0xff, 0xc6, 0x9a,
	0x12, 0xea, 0x7e, 0x02, 0xc3, 0x6a, 0xab, 0x70, 0x00, 0x7b, 0x73, 0xed, 0x07, 0xe7, 0x42, 0xb2,
	0x06, 0x0e, 0xa1, 0x47, 0x2f, 0xb1, 0x4e, 0x25, 0xb3, 0x1e, 0xfd, 0xfa, 0xd6, 0x57, 0xa5, 0xae,
	0x02, 0x7c, 0x08, 0xe3, 0xc2, 0x98, 0x57, 0x62, 0x58, 0x03, 0x19, 0x0c, 0xb9, 0xf0, 0xc3, 0xf5,
	0x49, 0x3a, 0x8b, 0xfd, 0x40, 0x30, 0x0b, 0x01, 0xba, 0x34, 0x0d, 0x59, 0x13, 0xf7, 0x61, 0x50,
	0x66, 0xa3, 0xe0, 0x9c, 0xb5, 0x28, 0x19, 0x05, 0xe7, 0x22, 0x64, 0x6d, 0x44, 0xb0, 0xcd, 0x8f,
	0x5b, 0xce, 0x36, 0x16, 0x5a, 0xb0, 0xce, 0xa3, 0x05, 0xbc, 0x7f, 0xa5, 0x2e, 0xf1, 0x43, 0x70,
	0x0c, 0x23, 0x03, 0xb9, 0xc4, 0x65, 0x08, 0xbd, 0xef, 0x44, 0x16, 0xa7, 0x6b, 0x11, 0x32, 0x0b,
	0xed, 0xed, 0xcf, 0x4c, 0xb2, 0x60, 0xcd, 0x3c, 0xcb, 0x4d, 0x93, 0x42, 0xd6, 0x9a, 0xfe, 0xd6,
	0x84, 0xd6, 0x9b, 0xa5, 0xc2, 0x9f, 0xe0, 0xbd, 0x9d, 0xf7, 0x53, 0x78, 0xff, 0x9a, 0xcf, 0xa8,
	0x73, 0x5d, 0xd2, 0x6d, 0x4c, 0xac, 0x23, 0x0b, 0x4f, 0xe1, 0xde, 0xae, 0xab, 0x28, 0x74, 0xae,
	0xf6, 0x9f, 0x73, 0x4d, 0xae, 0xd8, 0xd6, 0x83, 0x2e, 0xa9, 0x4b, 0xa1, 0x5d, 0xb7, 0x88, 0xf3,
	0xd6, 0xba, 0xc0, 0x3f, 0x81, 0xee, 0xf7, 0x22, 0x8e, 0x53, 0x85, 0x07, 0x55, 0x47, 0x52, 0xcc,
	0xb9, 0x1c, 0x32, 0x55, 0xdf, 0xde, 0xf9, 0x99, 0xfe, 0xda, 0xfc, 0xde, 0xa4, 0x61, 0xd6, 0x98,
	0x59, 0xb3, 0xe6, 0xac, 0x75, 0xd6, 0x25, 0xe9, 0x7d, 0xf6, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xae, 0x74, 0x88, 0x85, 0x04, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WmsClient is the client API for Wms service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WmsClient interface {
	// MaterialFlowOperations are the heart of this service; bidirectional streams which convey arrival or trays, confirmation
	// of tray positions, transfer requests, and completions.
	// MIGRATION: Tray Arrived and Response, Tray Transfer and Reply, Job Completion and Reply
	MaterialFlowOperations(ctx context.Context, opts ...grpc.CallOption) (Wms_MaterialFlowOperationsClient, error)
	// UrgentEventOperations are streamed by Conductor to WMS in order to interrupt operations and provide appropriate
	// mitigating action at a location (e.g deploy crane with fire suppressing equipment to a tray location, and on a
	// subsequent trigger, activate fire extinguisher). Conductor does this by indicating a desired state: Deployed,
	// Mitigating, Released to WMS.
	//
	// UrgentEventOperation are returned on the stream from WMS to Conductor in order to advise Conductor of
	// progress in mitigating an urgent operation e.g. Deploying, Deployed, Mitigating, Released.
	//
	// MIGRATION: This is covering the SmokeDetectEvents and Acknowledge in the proposed spec.
	UrgentEventOperations(ctx context.Context, opts ...grpc.CallOption) (Wms_UrgentEventOperationsClient, error)
	// Alarms are server side streamed from WMS to conductor using this service. The client side will return the alarm
	// in the client side stream as shown as an acknowledgement of the fault (but see migration note).
	//
	// MIGRATION: See open question re why WMS wants acknowledgement and specifically what should acknowledgment
	// signal?
	Alarms(ctx context.Context, opts ...grpc.CallOption) (Wms_AlarmsClient, error)
	// Hello service allows each end (client and server) to initiate an application level short exchange of hello
	// messages. Each end can control whether and how often it wishes to validate the roundtrip to the other endpoint.
	// When it wishes to do so, it would launch a Hello message in the stream with echo_request set to true, and nonce set
	// to a random number. The other end, when receiving a message with echo_request set to true, must reply in a timely
	// way with echo_request set to false and nonce copied from the original request.
	//
	// MIGRATION: This serves the purpose of 4 messages in original spec DateAndTime Req/Data and HeartBeat Req/Ack.
	Hellos(ctx context.Context, opts ...grpc.CallOption) (Wms_HellosClient, error)
}

type wmsClient struct {
	cc *grpc.ClientConn
}

func NewWmsClient(cc *grpc.ClientConn) WmsClient {
	return &wmsClient{cc}
}

func (c *wmsClient) MaterialFlowOperations(ctx context.Context, opts ...grpc.CallOption) (Wms_MaterialFlowOperationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Wms_serviceDesc.Streams[0], "/asrs.wms/MaterialFlowOperations", opts...)
	if err != nil {
		return nil, err
	}
	x := &wmsMaterialFlowOperationsClient{stream}
	return x, nil
}

type Wms_MaterialFlowOperationsClient interface {
	Send(*MaterialFlowOperation) error
	Recv() (*MaterialFlowOperation, error)
	grpc.ClientStream
}

type wmsMaterialFlowOperationsClient struct {
	grpc.ClientStream
}

func (x *wmsMaterialFlowOperationsClient) Send(m *MaterialFlowOperation) error {
	return x.ClientStream.SendMsg(m)
}

func (x *wmsMaterialFlowOperationsClient) Recv() (*MaterialFlowOperation, error) {
	m := new(MaterialFlowOperation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *wmsClient) UrgentEventOperations(ctx context.Context, opts ...grpc.CallOption) (Wms_UrgentEventOperationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Wms_serviceDesc.Streams[1], "/asrs.wms/UrgentEventOperations", opts...)
	if err != nil {
		return nil, err
	}
	x := &wmsUrgentEventOperationsClient{stream}
	return x, nil
}

type Wms_UrgentEventOperationsClient interface {
	Send(*UrgentEventOperation) error
	Recv() (*UrgentEventOperation, error)
	grpc.ClientStream
}

type wmsUrgentEventOperationsClient struct {
	grpc.ClientStream
}

func (x *wmsUrgentEventOperationsClient) Send(m *UrgentEventOperation) error {
	return x.ClientStream.SendMsg(m)
}

func (x *wmsUrgentEventOperationsClient) Recv() (*UrgentEventOperation, error) {
	m := new(UrgentEventOperation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *wmsClient) Alarms(ctx context.Context, opts ...grpc.CallOption) (Wms_AlarmsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Wms_serviceDesc.Streams[2], "/asrs.wms/Alarms", opts...)
	if err != nil {
		return nil, err
	}
	x := &wmsAlarmsClient{stream}
	return x, nil
}

type Wms_AlarmsClient interface {
	Send(*WMSAlarm) error
	Recv() (*WMSAlarm, error)
	grpc.ClientStream
}

type wmsAlarmsClient struct {
	grpc.ClientStream
}

func (x *wmsAlarmsClient) Send(m *WMSAlarm) error {
	return x.ClientStream.SendMsg(m)
}

func (x *wmsAlarmsClient) Recv() (*WMSAlarm, error) {
	m := new(WMSAlarm)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *wmsClient) Hellos(ctx context.Context, opts ...grpc.CallOption) (Wms_HellosClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Wms_serviceDesc.Streams[3], "/asrs.wms/Hellos", opts...)
	if err != nil {
		return nil, err
	}
	x := &wmsHellosClient{stream}
	return x, nil
}

type Wms_HellosClient interface {
	Send(*Hello) error
	Recv() (*Hello, error)
	grpc.ClientStream
}

type wmsHellosClient struct {
	grpc.ClientStream
}

func (x *wmsHellosClient) Send(m *Hello) error {
	return x.ClientStream.SendMsg(m)
}

func (x *wmsHellosClient) Recv() (*Hello, error) {
	m := new(Hello)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// WmsServer is the server API for Wms service.
type WmsServer interface {
	// MaterialFlowOperations are the heart of this service; bidirectional streams which convey arrival or trays, confirmation
	// of tray positions, transfer requests, and completions.
	// MIGRATION: Tray Arrived and Response, Tray Transfer and Reply, Job Completion and Reply
	MaterialFlowOperations(Wms_MaterialFlowOperationsServer) error
	// UrgentEventOperations are streamed by Conductor to WMS in order to interrupt operations and provide appropriate
	// mitigating action at a location (e.g deploy crane with fire suppressing equipment to a tray location, and on a
	// subsequent trigger, activate fire extinguisher). Conductor does this by indicating a desired state: Deployed,
	// Mitigating, Released to WMS.
	//
	// UrgentEventOperation are returned on the stream from WMS to Conductor in order to advise Conductor of
	// progress in mitigating an urgent operation e.g. Deploying, Deployed, Mitigating, Released.
	//
	// MIGRATION: This is covering the SmokeDetectEvents and Acknowledge in the proposed spec.
	UrgentEventOperations(Wms_UrgentEventOperationsServer) error
	// Alarms are server side streamed from WMS to conductor using this service. The client side will return the alarm
	// in the client side stream as shown as an acknowledgement of the fault (but see migration note).
	//
	// MIGRATION: See open question re why WMS wants acknowledgement and specifically what should acknowledgment
	// signal?
	Alarms(Wms_AlarmsServer) error
	// Hello service allows each end (client and server) to initiate an application level short exchange of hello
	// messages. Each end can control whether and how often it wishes to validate the roundtrip to the other endpoint.
	// When it wishes to do so, it would launch a Hello message in the stream with echo_request set to true, and nonce set
	// to a random number. The other end, when receiving a message with echo_request set to true, must reply in a timely
	// way with echo_request set to false and nonce copied from the original request.
	//
	// MIGRATION: This serves the purpose of 4 messages in original spec DateAndTime Req/Data and HeartBeat Req/Ack.
	Hellos(Wms_HellosServer) error
}

func RegisterWmsServer(s *grpc.Server, srv WmsServer) {
	s.RegisterService(&_Wms_serviceDesc, srv)
}

func _Wms_MaterialFlowOperations_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WmsServer).MaterialFlowOperations(&wmsMaterialFlowOperationsServer{stream})
}

type Wms_MaterialFlowOperationsServer interface {
	Send(*MaterialFlowOperation) error
	Recv() (*MaterialFlowOperation, error)
	grpc.ServerStream
}

type wmsMaterialFlowOperationsServer struct {
	grpc.ServerStream
}

func (x *wmsMaterialFlowOperationsServer) Send(m *MaterialFlowOperation) error {
	return x.ServerStream.SendMsg(m)
}

func (x *wmsMaterialFlowOperationsServer) Recv() (*MaterialFlowOperation, error) {
	m := new(MaterialFlowOperation)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Wms_UrgentEventOperations_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WmsServer).UrgentEventOperations(&wmsUrgentEventOperationsServer{stream})
}

type Wms_UrgentEventOperationsServer interface {
	Send(*UrgentEventOperation) error
	Recv() (*UrgentEventOperation, error)
	grpc.ServerStream
}

type wmsUrgentEventOperationsServer struct {
	grpc.ServerStream
}

func (x *wmsUrgentEventOperationsServer) Send(m *UrgentEventOperation) error {
	return x.ServerStream.SendMsg(m)
}

func (x *wmsUrgentEventOperationsServer) Recv() (*UrgentEventOperation, error) {
	m := new(UrgentEventOperation)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Wms_Alarms_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WmsServer).Alarms(&wmsAlarmsServer{stream})
}

type Wms_AlarmsServer interface {
	Send(*WMSAlarm) error
	Recv() (*WMSAlarm, error)
	grpc.ServerStream
}

type wmsAlarmsServer struct {
	grpc.ServerStream
}

func (x *wmsAlarmsServer) Send(m *WMSAlarm) error {
	return x.ServerStream.SendMsg(m)
}

func (x *wmsAlarmsServer) Recv() (*WMSAlarm, error) {
	m := new(WMSAlarm)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Wms_Hellos_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WmsServer).Hellos(&wmsHellosServer{stream})
}

type Wms_HellosServer interface {
	Send(*Hello) error
	Recv() (*Hello, error)
	grpc.ServerStream
}

type wmsHellosServer struct {
	grpc.ServerStream
}

func (x *wmsHellosServer) Send(m *Hello) error {
	return x.ServerStream.SendMsg(m)
}

func (x *wmsHellosServer) Recv() (*Hello, error) {
	m := new(Hello)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Wms_serviceDesc = grpc.ServiceDesc{
	ServiceName: "asrs.wms",
	HandlerType: (*WmsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MaterialFlowOperations",
			Handler:       _Wms_MaterialFlowOperations_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UrgentEventOperations",
			Handler:       _Wms_UrgentEventOperations_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Alarms",
			Handler:       _Wms_Alarms_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Hellos",
			Handler:       _Wms_Hellos_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "asrs.proto",
}
